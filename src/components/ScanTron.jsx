import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { addCompletedTest } from "../Api/api";
import {
  Radio,
  RadioGroup,
  FormControlLabel,
  FormControl,
  FormLabel,
  Paper,
  Button,
} from "@mui/material";

const ScanTron = ({ testKey, testTopic, _id }) => {
  // a,j,a,j,a,j,a,j,a,j,a,j,a,j,a,j,a,j,a,j,a,j,a,j,a,j,a,j,a,j

  const [keyArr, setKeyArr] = useState([]);
  const [testLength, setTestLength] = useState(40);
  const [onChangeAnswers, setOnChangeAnswers] = useState({});
  const [submittedAnswers, setSubmittedAnswers] = useState([]);
  const [score, setScore] = useState("");

  const navigate = useNavigate();

  useEffect(() => {
    const setUp = () => {
      if (testKey) {
        let keyData = testKey.split(",");
        setKeyArr(keyData); // Updates keyArr state
        setTestLength(keyData.length); // Directly use keyData for immediate logic
      }
    };
    setUp();
  }, [testKey]);

  useEffect(() => {
    //console.log(keyArr); // This will log the updated keyArr after it changes
  }, [keyArr]);

  const handleRadioChange = (question, event) => {
    setOnChangeAnswers({
      ...onChangeAnswers,
      [question]: event.target.value,
    });
  };

  const handleSubmit = async () => {
    // Initialize an empty array to store answers.
    const answersArray = [];

    // Loop through each question based on the test length that was generated by keyArr.length
    for (let i = 0; i < testLength; i++) {
      // Construct the key for fetching the answer. E.g., for i=0, the key will be "question1".
      const questionKey = `question${i + 1}`;
      // Get the answer using the constructed key from onChangeAnswers.
      const answer = onChangeAnswers[questionKey];
      // Push the answer (or an empty string if undefined) to our answers array.
      answersArray.push(answer || "");
    }

    console.log("Correct Answers (keyArr):", keyArr);
    console.log("User Answers (answersArray):", answersArray);

    // Calculate the score by comparing answersArray with keyArr.
    let count = 0;
    for (let i = 0; i < keyArr.length; i++) {
      if (keyArr[i] === answersArray[i]) {
        count++;
      }
    }

    // Calculate the percentage score and update the score state.
    const equation = Math.round((count / testLength) * 100);
    setScore(equation.toString());

    // Create the completed test object
    const completedTest = {
      testTopic,
      score: equation,
    };

    // Make an asynchronous call to save the completed test data
    try {
      const response = await addCompletedTest(_id, completedTest);
      // Navigate to the archive page if successful
      if (response.success === true) {
        navigate("/archive");
      }
    } catch (error) {
      console.log(error);
    }
  };

  const oddOptions = ["A", "B", "C", "D"];
  const evenOptions = ["F", "G", "H", "J"];

  return (
    <Paper
      style={{ maxWidth: "100%", maxHeight: "60vh", overflowY: "auto" }}
      className="dev-border"
    >
      <h3>ScanTron</h3>

      {/* Generate a list of questions based on the testLength */}
      {Array.from({ length: testLength }).map((_, index) => {
        // Calculate the current question number
        const questionNumber = index + 1;

        return (
          <div key={questionNumber}>
            {/* Form container for individual question */}
            <FormControl component="fieldset" style={{ marginBottom: "15px" }}>
              {/* Label for the question */}
              <FormLabel component="legend">
                Question {questionNumber}
              </FormLabel>

              {/* Radio buttons for the question's options */}
              <RadioGroup
                row
                name={`question${questionNumber}`} // Dynamic name based on the question number
                value={onChangeAnswers[`question${questionNumber}`] || ""} // Current value of this question from state
                onChange={(e) =>
                  handleRadioChange(`question${questionNumber}`, e)
                } // Update state on change
              >
                {/* Map over either odd or even options based on the question number */}
                {(questionNumber % 2 === 1 ? oddOptions : evenOptions).map(
                  (option) => (
                    <FormControlLabel
                      key={option}
                      value={option}
                      control={<Radio />}
                      label={option}
                    />
                  )
                )}
              </RadioGroup>
            </FormControl>

            {/* horizontal rule between questions, but not after the last one */}
            {index !== testLength - 1 && <hr />}
          </div>
        );
      })}

      <Button variant="contained" color="primary" onClick={handleSubmit}>
        Submit
      </Button>
    </Paper>
  );
};

export default ScanTron;

//   const handleSubmit = async () => {
//     // Initialize an empty array to store answers.
//     const answersArray = [];

//     // Loop through each question based on the test length that was generated by keyArr.length
//     for (let i = 0; i < testLength; i++) {
//       // Construct the key for fetching the answer. E.g., for i=0, the key will be "question1".
//       const questionKey = `question${i + 1}`;
//       // Try to get the answer using the constructed key from onChangeAnswers.
//       // If no answer is found for the given key, default to an empty string.
//       const answer = onChangeAnswers[questionKey] || "";
//       // push the found (or default) answer to our answers array.
//       answersArray.push(answer);
//     }
//     //Save the array of answers to the state.
//     setSubmittedAnswers(answersArray);

//     // Calculate the score by comparing answersArray with keyArr.
//     // Initialize a count to keep track of correct answers.
//     let count = 0;
//     for (let i = 0; i < keyArr.length; i++) {
//       // For each answer, compare it with the correct answer in keyArr.
//       // If they match, increase the count.
//       if (keyArr[i] === answersArray[i]) {
//         count++;
//       }
//     }

//     // Calculate the percentage score.
//     // dividing the count of correct answers by the total number of questions and then multiplying by 100.
//     const equation = (100 / testLength) * count;

//     // Update the score state with the calculated score, converting it to a string.
//     setScore(equation.toString());

//     // Create an object based on the Mongoose schema to save the completed test data.
//     const completedTest = {
//       testTopic,
//       score,
//     };

//     // Make an asynchronous call to save the completed test data.
//     try {
//       const response = await addCompletedTest(_id, completedTest);

//       // If the test data is successfully saved, reset various states to their initial values.
//       if (response.success === true) {
//         setKeyArr([]); // Reset the keyArr state (array of correct answers)
//         setOnChangeAnswers({}); // Reset the onChangeAnswers state (answers provided by the user)
//         setSubmittedAnswers([]); // Reset the submittedAnswers state
//         setScore(""); // Reset the score state to an empty string

//         // Navigate to the archive page.
//         navigate("/archive");
//       }
//     } catch (error) {
//       // If there's an error in the asynchronous call, log the error.
//       console.log(error);
//     }
//   };
